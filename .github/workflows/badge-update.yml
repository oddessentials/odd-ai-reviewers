name: Update Badges

# FR-030: Separate post-merge workflow for badge updates
# This workflow runs after the main CI workflow completes on main branch
# PR workflow does NOT depend on Gist availability (FR-031)

on:
  # Primary trigger: after CI workflow completes on main
  workflow_run:
    workflows: ['CI']
    types:
      - completed
    branches:
      - main

  # Manual trigger for debugging
  workflow_dispatch:

jobs:
  update-badges:
    name: Update Badge Gists
    runs-on: ubuntu-latest
    # Only run if CI workflow succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      # Try to download artifacts from CI workflow (FR-031 optimization)
      - name: Download test artifacts
        id: download-artifacts
        uses: actions/download-artifact@v4
        with:
          name: test-results
          path: router/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
        continue-on-error: true

      # Fallback: run tests if artifacts not available (e.g., workflow_dispatch)
      - name: Setup pnpm
        if: steps.download-artifacts.outcome == 'failure'
        uses: pnpm/action-setup@v4
        # Version is read from packageManager field in package.json

      - name: Setup Node.js
        if: steps.download-artifacts.outcome == 'failure'
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        if: steps.download-artifacts.outcome == 'failure'
        run: pnpm install --frozen-lockfile

      - name: Build router
        if: steps.download-artifacts.outcome == 'failure'
        run: pnpm --filter ./router build

      - name: Run tests with coverage
        if: steps.download-artifacts.outcome == 'failure'
        run: pnpm --filter ./router test:ci:coverage
        env:
          CI: 'true'
          CI_HAS_LSOF: 'true'

      - name: Generate test badge data
        run: |
          PASSED=$(jq '.numPassedTests' router/test-results.json)
          SKIPPED=$(jq '.numPendingTests' router/test-results.json)
          FAILED=$(jq '.numFailedTests' router/test-results.json)

          if [ "$FAILED" -gt 0 ]; then
            COLOR="red"
            MESSAGE="${PASSED} passed, ${FAILED} failed"
          elif [ "$SKIPPED" -gt 0 ]; then
            COLOR="green"
            MESSAGE="${PASSED} passed, ${SKIPPED} skipped"
          else
            COLOR="brightgreen"
            MESSAGE="${PASSED} passed"
          fi

          mkdir -p .github/badges
          echo "{\"schemaVersion\":1,\"label\":\"tests\",\"message\":\"$MESSAGE\",\"color\":\"$COLOR\"}" > .github/badges/tests.json

      - name: Generate coverage badge data
        run: |
          # Extract line coverage percentage from coverage-summary.json
          COVERAGE=$(jq '.total.lines.pct' router/coverage/coverage-summary.json)

          # Determine badge color based on coverage percentage
          if (( $(echo "$COVERAGE < 50" | bc -l) )); then
            COLOR="red"
          elif (( $(echo "$COVERAGE < 70" | bc -l) )); then
            COLOR="yellow"
          elif (( $(echo "$COVERAGE < 80" | bc -l) )); then
            COLOR="green"
          else
            COLOR="brightgreen"
          fi

          mkdir -p .github/badges
          echo "{\"schemaVersion\":1,\"label\":\"coverage\",\"message\":\"${COVERAGE}%\",\"color\":\"$COLOR\"}" > .github/badges/coverage.json

      # T014-T016: Replace unpinned third-party action with official GitHub action
      # Using actions/github-script with inline Octokit to minimize supply chain risk
      # SHA-pinned for supply chain hardening (v7.0.1)
      - name: Update test badge Gist
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          github-token: ${{ secrets.GIST_TOKEN }}
          script: |
            const fs = require('fs');
            const gistId = '${{ vars.TEST_BADGE_GIST_ID }}';
            const filePath = '.github/badges/tests.json';

            // Validate inputs
            if (!gistId || gistId === '') {
              core.setFailed('TEST_BADGE_GIST_ID variable is not set');
              return;
            }

            const content = fs.readFileSync(filePath, 'utf8');
            if (!content || content.trim() === '') {
              core.setFailed(`Badge file ${filePath} is empty`);
              return;
            }

            try {
              const response = await github.rest.gists.update({
                gist_id: gistId,
                files: { 'tests.json': { content } }
              });
              console.log(`Test badge updated (status: ${response.status}, gist: ${gistId})`);
            } catch (error) {
              core.setFailed(`Failed to update test badge gist: ${error.message} (status: ${error.status || 'unknown'})`);
            }

      - name: Update coverage badge Gist
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7
        with:
          github-token: ${{ secrets.GIST_TOKEN }}
          script: |
            const fs = require('fs');
            const gistId = '${{ vars.COVERAGE_BADGE_GIST_ID }}';
            const filePath = '.github/badges/coverage.json';

            // Validate inputs
            if (!gistId || gistId === '') {
              core.setFailed('COVERAGE_BADGE_GIST_ID variable is not set');
              return;
            }

            const content = fs.readFileSync(filePath, 'utf8');
            if (!content || content.trim() === '') {
              core.setFailed(`Badge file ${filePath} is empty`);
              return;
            }

            try {
              const response = await github.rest.gists.update({
                gist_id: gistId,
                files: { 'coverage.json': { content } }
              });
              console.log(`Coverage badge updated (status: ${response.status}, gist: ${gistId})`);
            } catch (error) {
              core.setFailed(`Failed to update coverage badge gist: ${error.message} (status: ${error.status || 'unknown'})`);
            }
