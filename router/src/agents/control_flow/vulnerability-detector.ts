/**
 * Vulnerability Detector
 *
 * Identifies potential security vulnerabilities by detecting dangerous sinks
 * and tracking taint from user input sources.
 *
 * Implements the missing piece that connects CFG/mitigation analysis to findings.
 */

import ts from 'typescript';
import type { VulnerabilityType, PotentialVulnerability, SourceLocation } from './types.js';
import type { ControlFlowGraphRuntime } from './cfg-types.js';
import { getLogger, type AnalysisLogger } from './logger.js';

// =============================================================================
// Sink Patterns - Dangerous operations that could be vulnerable
// =============================================================================

interface SinkPattern {
  type: VulnerabilityType;
  /** Function/method names that are sinks */
  names: string[];
  /** Regex patterns for matching */
  patterns?: RegExp[];
  /** Object/class the method belongs to (optional) */
  objects?: string[];
  /** Description for findings */
  description: string;
}

/**
 * Built-in sink patterns for common vulnerability types.
 */
const SINK_PATTERNS: SinkPattern[] = [
  // SQL Injection sinks
  {
    type: 'injection',
    names: ['query', 'execute', 'raw', 'exec'],
    objects: ['db', 'database', 'connection', 'pool', 'knex', 'sequelize', 'prisma'],
    description: 'SQL query execution with potentially unsanitized input',
  },
  {
    type: 'injection',
    names: ['eval', 'Function'],
    description: 'Dynamic code execution with potentially unsanitized input',
  },
  {
    type: 'injection',
    names: ['exec', 'execSync', 'spawn', 'spawnSync', 'execFile'],
    objects: ['child_process', 'childProcess'],
    description: 'Command execution with potentially unsanitized input',
  },

  // XSS sinks
  {
    type: 'xss',
    names: ['innerHTML', 'outerHTML', 'insertAdjacentHTML'],
    description: 'DOM manipulation with potentially unsanitized HTML',
  },
  {
    type: 'xss',
    names: ['write', 'writeln'],
    objects: ['document'],
    description: 'Document write with potentially unsanitized content',
  },
  {
    type: 'xss',
    names: ['dangerouslySetInnerHTML'],
    description: 'React dangerous HTML injection',
  },

  // Path Traversal sinks
  {
    type: 'path_traversal',
    names: ['readFile', 'readFileSync', 'writeFile', 'writeFileSync', 'unlink', 'rmdir', 'mkdir'],
    objects: ['fs', 'promises'],
    description: 'File system operation with potentially unsanitized path',
  },
  {
    type: 'path_traversal',
    names: ['createReadStream', 'createWriteStream'],
    objects: ['fs'],
    description: 'File stream with potentially unsanitized path',
  },

  // SSRF sinks
  {
    type: 'ssrf',
    names: ['fetch', 'request', 'get', 'post', 'put', 'delete', 'patch'],
    objects: ['axios', 'http', 'https', 'got', 'superagent'],
    description: 'HTTP request with potentially unsanitized URL',
  },

  // Prototype Pollution sinks
  {
    type: 'prototype_pollution',
    names: ['merge', 'extend', 'defaultsDeep', 'assign'],
    patterns: [/Object\.assign/, /\.\.\./, /\[.*\]\s*=/],
    description: 'Object manipulation that could lead to prototype pollution',
  },

  // Auth Bypass - checking for missing auth
  {
    type: 'auth_bypass',
    names: ['delete', 'update', 'create', 'admin', 'sudo'],
    description: 'Sensitive operation that may require authentication',
  },
];

// =============================================================================
// Source Patterns - User input that could be tainted
// =============================================================================

interface SourcePattern {
  /** Property/variable names that are taint sources */
  names: string[];
  /** Object names the property belongs to */
  objects?: string[];
  /** Regex patterns */
  patterns?: RegExp[];
}

/**
 * Built-in source patterns for user input.
 */
const SOURCE_PATTERNS: SourcePattern[] = [
  // Express/HTTP request sources
  {
    names: ['body', 'query', 'params', 'headers', 'cookies'],
    objects: ['req', 'request', 'ctx'],
  },
  // URL/Location sources
  {
    names: ['search', 'hash', 'pathname', 'href'],
    objects: ['location', 'url', 'URL'],
  },
  // Form/DOM sources
  {
    names: ['value', 'innerHTML', 'textContent'],
    objects: ['input', 'textarea', 'element'],
  },
  // Generic user input patterns
  {
    names: ['userInput', 'userData', 'input', 'data'],
    patterns: [/user[A-Z]/, /input[A-Z]/, /param[A-Z]/],
  },
];

// =============================================================================
// Detected Sink/Source Types
// =============================================================================

interface DetectedSink {
  type: VulnerabilityType;
  location: SourceLocation;
  expression: string;
  description: string;
  nodeId?: string;
}

interface DetectedSource {
  location: SourceLocation;
  expression: string;
  variableName: string;
}

interface TaintedVariable {
  name: string;
  sourceLocation: SourceLocation;
  taintedAt: SourceLocation;
}

// =============================================================================
// Vulnerability Detector Class
// =============================================================================

/**
 * Detects potential vulnerabilities by identifying dangerous sinks
 * and tracking taint propagation from user input sources.
 */
export class VulnerabilityDetector {
  private logger: AnalysisLogger;
  private sinkPatterns: SinkPattern[];
  private sourcePatterns: SourcePattern[];

  constructor(logger?: AnalysisLogger) {
    this.logger = logger ?? getLogger();
    this.sinkPatterns = [...SINK_PATTERNS];
    this.sourcePatterns = [...SOURCE_PATTERNS];
  }

  /**
   * Detect potential vulnerabilities in a source file.
   *
   * Returns a list of potential vulnerabilities that need mitigation checking.
   */
  detectInFile(
    sourceFile: ts.SourceFile,
    filePath: string,
    cfg?: ControlFlowGraphRuntime
  ): PotentialVulnerability[] {
    const vulnerabilities: PotentialVulnerability[] = [];
    const detectedSinks: DetectedSink[] = [];
    const detectedSources: DetectedSource[] = [];
    const taintedVariables: TaintedVariable[] = [];

    // Step 1: Find all sinks (dangerous operations)
    this.findSinks(sourceFile, filePath, detectedSinks);

    // Step 2: Find all sources (user input)
    this.findSources(sourceFile, filePath, detectedSources);

    // Step 3: Track taint propagation
    this.trackTaint(sourceFile, filePath, detectedSources, taintedVariables);

    // Step 4: Match sinks to tainted data
    for (const sink of detectedSinks) {
      const affectedVariable = this.findAffectedVariable(sink, taintedVariables, sourceFile);

      if (affectedVariable) {
        const vuln = this.createVulnerability(sink, affectedVariable, filePath, cfg);
        vulnerabilities.push(vuln);
      }
    }

    this.logger.log('debug', 'vulnerability', 'Vulnerability detection complete', {
      file: filePath,
      sinksFound: detectedSinks.length,
      sourcesFound: detectedSources.length,
      taintedVars: taintedVariables.length,
      vulnerabilities: vulnerabilities.length,
    });

    return vulnerabilities;
  }

  /**
   * Find dangerous sinks in the source file.
   */
  private findSinks(sourceFile: ts.SourceFile, filePath: string, sinks: DetectedSink[]): void {
    const visit = (node: ts.Node): void => {
      // Check call expressions
      if (ts.isCallExpression(node)) {
        this.checkCallExpressionForSink(node, sourceFile, filePath, sinks);
      }

      // Check property assignments (for innerHTML, etc.)
      if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {
        this.checkAssignmentForSink(node, sourceFile, filePath, sinks);
      }

      // Check property access that might be sinks
      if (ts.isPropertyAccessExpression(node)) {
        this.checkPropertyAccessForSink(node, sourceFile, filePath, sinks);
      }

      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
  }

  /**
   * Check if a call expression is a sink.
   */
  private checkCallExpressionForSink(
    node: ts.CallExpression,
    sourceFile: ts.SourceFile,
    filePath: string,
    sinks: DetectedSink[]
  ): void {
    let functionName = '';
    let objectName = '';

    if (ts.isIdentifier(node.expression)) {
      functionName = node.expression.text;
    } else if (ts.isPropertyAccessExpression(node.expression)) {
      functionName = node.expression.name.text;
      if (ts.isIdentifier(node.expression.expression)) {
        objectName = node.expression.expression.text;
      }
    }

    for (const pattern of this.sinkPatterns) {
      const nameMatches = pattern.names.includes(functionName);
      const objectMatches =
        !pattern.objects ||
        pattern.objects.some((obj) => objectName.toLowerCase().includes(obj.toLowerCase()));

      if (nameMatches && objectMatches) {
        const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
        const { line: endLine } = sourceFile.getLineAndCharacterOfPosition(node.getEnd());

        sinks.push({
          type: pattern.type,
          location: {
            file: filePath,
            line: line + 1,
            column: character,
            endLine: endLine + 1,
          },
          expression: node.getText(sourceFile),
          description: pattern.description,
        });
        break;
      }
    }
  }

  /**
   * Check if an assignment is to a dangerous property (like innerHTML).
   */
  private checkAssignmentForSink(
    node: ts.BinaryExpression,
    sourceFile: ts.SourceFile,
    filePath: string,
    sinks: DetectedSink[]
  ): void {
    if (!ts.isPropertyAccessExpression(node.left)) return;

    const propName = node.left.name.text;

    for (const pattern of this.sinkPatterns) {
      if (pattern.names.includes(propName)) {
        const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
        const { line: endLine } = sourceFile.getLineAndCharacterOfPosition(node.getEnd());

        sinks.push({
          type: pattern.type,
          location: {
            file: filePath,
            line: line + 1,
            column: character,
            endLine: endLine + 1,
          },
          expression: node.getText(sourceFile),
          description: pattern.description,
        });
        break;
      }
    }
  }

  /**
   * Check property access for sink patterns.
   */
  private checkPropertyAccessForSink(
    node: ts.PropertyAccessExpression,
    sourceFile: ts.SourceFile,
    filePath: string,
    sinks: DetectedSink[]
  ): void {
    // Skip if this is part of a call expression (handled separately)
    if (ts.isCallExpression(node.parent) && node.parent.expression === node) {
      return;
    }

    const propName = node.name.text;

    // Check for dangerous property reads that indicate potential issues
    const dangerousReads = ['__proto__', 'constructor', 'prototype'];
    if (dangerousReads.includes(propName)) {
      const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());

      sinks.push({
        type: 'prototype_pollution',
        location: {
          file: filePath,
          line: line + 1,
          column: character,
        },
        expression: node.getText(sourceFile),
        description: 'Access to prototype chain property',
      });
    }
  }

  /**
   * Find user input sources in the source file.
   */
  private findSources(
    sourceFile: ts.SourceFile,
    filePath: string,
    sources: DetectedSource[]
  ): void {
    const visit = (node: ts.Node): void => {
      // Check property access for source patterns
      if (ts.isPropertyAccessExpression(node)) {
        this.checkPropertyAccessForSource(node, sourceFile, filePath, sources);
      }

      // Check element access (e.g., req['body'])
      if (ts.isElementAccessExpression(node)) {
        this.checkElementAccessForSource(node, sourceFile, filePath, sources);
      }

      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
  }

  /**
   * Check if property access is a taint source.
   */
  private checkPropertyAccessForSource(
    node: ts.PropertyAccessExpression,
    sourceFile: ts.SourceFile,
    filePath: string,
    sources: DetectedSource[]
  ): void {
    const propName = node.name.text;
    let objectName = '';

    if (ts.isIdentifier(node.expression)) {
      objectName = node.expression.text;
    }

    for (const pattern of this.sourcePatterns) {
      const nameMatches = pattern.names.includes(propName);
      const objectMatches =
        !pattern.objects ||
        pattern.objects.some((obj) => objectName.toLowerCase() === obj.toLowerCase());

      if (nameMatches && objectMatches) {
        const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());

        sources.push({
          location: {
            file: filePath,
            line: line + 1,
            column: character,
          },
          expression: node.getText(sourceFile),
          variableName: this.findAssignedVariable(node, sourceFile) || propName,
        });
        break;
      }
    }
  }

  /**
   * Check element access for source patterns (e.g., req['body']).
   */
  private checkElementAccessForSource(
    node: ts.ElementAccessExpression,
    sourceFile: ts.SourceFile,
    filePath: string,
    sources: DetectedSource[]
  ): void {
    if (!ts.isStringLiteral(node.argumentExpression)) return;

    const propName = node.argumentExpression.text;
    let objectName = '';

    if (ts.isIdentifier(node.expression)) {
      objectName = node.expression.text;
    }

    for (const pattern of this.sourcePatterns) {
      const nameMatches = pattern.names.includes(propName);
      const objectMatches =
        !pattern.objects ||
        pattern.objects.some((obj) => objectName.toLowerCase() === obj.toLowerCase());

      if (nameMatches && objectMatches) {
        const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());

        sources.push({
          location: {
            file: filePath,
            line: line + 1,
            column: character,
          },
          expression: node.getText(sourceFile),
          variableName: this.findAssignedVariable(node, sourceFile) || propName,
        });
        break;
      }
    }
  }

  /**
   * Find the variable a source is assigned to.
   */
  private findAssignedVariable(node: ts.Node, _sourceFile: ts.SourceFile): string | null {
    let current: ts.Node | undefined = node.parent;

    while (current) {
      if (ts.isVariableDeclaration(current) && ts.isIdentifier(current.name)) {
        return current.name.text;
      }
      if (
        ts.isBinaryExpression(current) &&
        current.operatorToken.kind === ts.SyntaxKind.EqualsToken &&
        ts.isIdentifier(current.left)
      ) {
        return current.left.text;
      }
      current = current.parent;
    }

    return null;
  }

  /**
   * Track taint propagation through variable assignments.
   */
  private trackTaint(
    sourceFile: ts.SourceFile,
    filePath: string,
    sources: DetectedSource[],
    tainted: TaintedVariable[]
  ): void {
    // Initialize tainted variables from sources
    for (const source of sources) {
      tainted.push({
        name: source.variableName,
        sourceLocation: source.location,
        taintedAt: source.location,
      });
    }

    // Track taint through assignments
    const visit = (node: ts.Node): void => {
      if (ts.isVariableDeclaration(node) && ts.isIdentifier(node.name) && node.initializer) {
        const varName = node.name.text;
        const taintSource = this.findTaintInExpression(node.initializer, tainted, sourceFile);

        if (taintSource) {
          const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
          tainted.push({
            name: varName,
            sourceLocation: taintSource.sourceLocation,
            taintedAt: { file: filePath, line: line + 1, column: character },
          });
        }
      }

      if (
        ts.isBinaryExpression(node) &&
        node.operatorToken.kind === ts.SyntaxKind.EqualsToken &&
        ts.isIdentifier(node.left)
      ) {
        const varName = node.left.text;
        const taintSource = this.findTaintInExpression(node.right, tainted, sourceFile);

        if (taintSource) {
          const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
          tainted.push({
            name: varName,
            sourceLocation: taintSource.sourceLocation,
            taintedAt: { file: filePath, line: line + 1, column: character },
          });
        }
      }

      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
  }

  /**
   * Find if an expression uses a tainted variable.
   */
  private findTaintInExpression(
    node: ts.Node,
    tainted: TaintedVariable[],
    _sourceFile: ts.SourceFile
  ): TaintedVariable | null {
    if (ts.isIdentifier(node)) {
      return tainted.find((t) => t.name === node.text) || null;
    }

    let found: TaintedVariable | null = null;
    node.forEachChild((child) => {
      if (!found) {
        found = this.findTaintInExpression(child, tainted, _sourceFile);
      }
    });

    return found;
  }

  /**
   * Find the affected variable for a sink.
   */
  private findAffectedVariable(
    sink: DetectedSink,
    tainted: TaintedVariable[],
    sourceFile: ts.SourceFile
  ): TaintedVariable | null {
    // Parse the sink expression to find referenced variables
    const sinkText = sink.expression;

    for (const taintedVar of tainted) {
      // Check if the tainted variable is used in the sink
      // eslint-disable-next-line security/detect-non-literal-regexp -- Variable name is from analyzed code, not user input
      const varPattern = new RegExp(`\\b${taintedVar.name}\\b`);
      if (varPattern.test(sinkText)) {
        return taintedVar;
      }
    }

    // Also check for common patterns where taint flows through function params
    // This is a simplified check - full taint tracking would be more complex
    const functionParams = this.extractFunctionParams(sourceFile, sink.location.line);
    for (const param of functionParams) {
      const taintedParam = tainted.find((t) => t.name === param);
      if (taintedParam) {
        return taintedParam;
      }
    }

    return null;
  }

  /**
   * Extract function parameters that could carry taint.
   */
  private extractFunctionParams(sourceFile: ts.SourceFile, _line: number): string[] {
    const params: string[] = [];

    const visit = (node: ts.Node): void => {
      if (
        ts.isFunctionDeclaration(node) ||
        ts.isFunctionExpression(node) ||
        ts.isArrowFunction(node) ||
        ts.isMethodDeclaration(node)
      ) {
        for (const param of node.parameters) {
          if (ts.isIdentifier(param.name)) {
            params.push(param.name.text);
          }
        }
      }
      ts.forEachChild(node, visit);
    };

    visit(sourceFile);
    return params;
  }

  /**
   * Create a PotentialVulnerability from detected sink and taint.
   */
  private createVulnerability(
    sink: DetectedSink,
    taintedVar: TaintedVariable,
    _filePath: string,
    _cfg?: ControlFlowGraphRuntime
  ): PotentialVulnerability {
    const id = `vuln-${sink.type}-${sink.location.line}-${taintedVar.name}`;

    return {
      id,
      type: sink.type,
      sinkLocation: sink.location,
      taintedSource: taintedVar.sourceLocation,
      affectedVariable: taintedVar.name,
      requiredMitigations: [sink.type],
      description: `${sink.description}. Tainted data from '${taintedVar.name}' flows to this sink.`,
    };
  }
}

// =============================================================================
// Factory Function
// =============================================================================

/**
 * Create a vulnerability detector instance.
 */
export function createVulnerabilityDetector(logger?: AnalysisLogger): VulnerabilityDetector {
  return new VulnerabilityDetector(logger);
}
