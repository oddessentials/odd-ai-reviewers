/**
 * Docs Viewer - AI Reviewers Documentation Tool
 * A secure, GitHub Pages-compatible viewer for project documentation.
 *
 * SECURITY MODEL:
 * 1. File Allowlist: Only files listed in manifest.json can be loaded.
 *    The manifest is generated at build time by a trusted script.
 * 2. Content Sanitization: All markdown content is sanitized via DOMPurify
 *    before rendering, with a strict allowlist of tags and attributes.
 * 3. Safe DOM Construction: File tree and UI elements use textContent and
 *    DOM APIs instead of innerHTML to prevent XSS from manifest data.
 * 4. CSP Headers: Content Security Policy in index.html restricts scripts.
 */

const DocsViewer = {
  // Base path for content files (relative to /docs/viewer)
  basePath: '../',

  // File tree - Loaded dynamically from manifest.json
  // The manifest is generated by scripts/generate-docs-manifest.cjs
  // This maintains security by only allowing files listed in the manifest
  fileTree: [],

  // Get flat list of allowed paths for validation
  getAllowedPaths() {
    return this.fileTree.map((item) => item.name);
  },

  /**
   * Check if a path is valid (exists in manifest).
   * @param {string} path - The document path to validate
   * @returns {boolean} True if path is in manifest
   */
  isValidPath(path) {
    if (!path) return false;
    const allowed = this.getAllowedPaths();
    return allowed.some((p) => p.toLowerCase() === path.toLowerCase());
  },

  /**
   * Display a consistent "document not found" message.
   * Used for all three entry points: direct hash, link click, back/forward.
   * @param {string} docPath - The path that was not found
   */
  showNotFound(docPath) {
    const headerDiv = document.querySelector('#content-primary .content-header');
    const bodyDiv = document.querySelector('#content-primary .content-body');

    if (headerDiv) {
      const slot = headerDiv.querySelector('.file-path-slot');
      if (slot) slot.textContent = 'Not Found';
    }

    if (bodyDiv) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error not-found';
      errorDiv.innerHTML = `
        <h2>Document Not Found</h2>
        <p>The requested document could not be found:</p>
        <code>${DOMPurify.sanitize(docPath)}</code>
        <p>Please check the URL or select a document from the sidebar.</p>
      `;
      bodyDiv.innerHTML = '';
      bodyDiv.appendChild(errorDiv);
    }

    // Clear current file state
    this.state.currentFile = null;
  },

  // FR-013: Graceful fallback when index.md doesn't exist
  showWelcome() {
    const headerDiv = document.querySelector('#content-primary .content-header');
    const bodyDiv = document.querySelector('#content-primary .content-body');

    if (headerDiv) {
      const slot = headerDiv.querySelector('.file-path-slot');
      if (slot) slot.textContent = 'Welcome';
    }

    if (bodyDiv) {
      const welcomeDiv = document.createElement('div');
      welcomeDiv.className = 'welcome markdown-body';
      const fileCount = this.fileTree?.length || 0;
      welcomeDiv.innerHTML = `
        <h1>Documentation Viewer</h1>
        <p>Welcome to the documentation viewer. Select a document from the sidebar to get started.</p>
        <p><strong>${fileCount}</strong> document${fileCount !== 1 ? 's' : ''} available.</p>
        <p><em>Tip: Create an <code>index.md</code> file in the docs folder to customize this landing page.</em></p>
      `;
      bodyDiv.innerHTML = '';
      bodyDiv.appendChild(welcomeDiv);
    }

    // Clear current file state
    this.state.currentFile = null;
  },

  // Application state
  state: {
    currentFile: null,
    compareFile: null,
    compareMode: false,
  },

  // Cache for loaded content (id -> html)
  contentCache: new Map(),

  // Icons
  icons: {
    markdown: `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`,
    folder: `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>`,
    folderOpen: `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2v1"></path><path d="M4 10h16l-3 9H7l-3-9z"></path></svg>`,
    compare: `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="18" rx="1"></rect><rect x="14" y="3" width="7" height="18" rx="1"></rect></svg>`,
    close: `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`,
  },

  // Cached parsed icon elements for safe reuse (populated on first use)
  iconElements: null,

  /**
   * Parse icon SVG strings into DOM elements once, then clone for reuse.
   * SECURITY: Avoids innerHTML by parsing trusted static strings once.
   */
  parseIcons() {
    const parser = new DOMParser();
    this.iconElements = {};
    for (const [name, svg] of Object.entries(this.icons)) {
      const doc = parser.parseFromString(svg, 'image/svg+xml');
      this.iconElements[name] = doc.documentElement;
    }
  },

  /**
   * Create a clone of a named icon for safe DOM insertion.
   * @param {string} name - Icon name from this.icons
   * @returns {Element} Cloned SVG element
   */
  createIcon(name) {
    if (!this.iconElements) this.parseIcons();
    return this.iconElements[name].cloneNode(true);
  },

  /**
   * Safely set link content with icon and text.
   * SECURITY: Uses textContent for the name to prevent XSS.
   * @param {Element} link - The anchor element
   * @param {string} iconName - Icon name from this.icons
   * @param {string} text - Text content for the name span
   */
  setLinkContent(link, iconName, text) {
    link.innerHTML = '';
    link.appendChild(this.createIcon(iconName));
    const nameSpan = document.createElement('span');
    nameSpan.className = 'name';
    nameSpan.textContent = text;
    link.appendChild(nameSpan);
  },

  // Build file tree with folder support
  buildTree(items, parentUl, paneId = 'primary') {
    for (const item of items) {
      const li = document.createElement('li');

      if (item.type === 'folder') {
        // Create folder item with expand/collapse
        li.className = 'folder-item';
        const folderHeader = document.createElement('a');
        folderHeader.href = '#';
        folderHeader.className = 'folder-link';
        this.setLinkContent(folderHeader, 'folder', item.name);

        const childUl = document.createElement('ul');
        childUl.className = 'folder-children';
        childUl.style.display = 'none';

        folderHeader.onclick = (e) => {
          e.preventDefault();
          const isOpen = childUl.style.display !== 'none';
          childUl.style.display = isOpen ? 'none' : 'block';
          this.setLinkContent(folderHeader, isOpen ? 'folder' : 'folderOpen', item.name);
          li.classList.toggle('open', !isOpen);
        };

        li.appendChild(folderHeader);
        if (item.children && item.children.length > 0) {
          this.buildTree(item.children, childUl, paneId);
        }
        li.appendChild(childUl);
      } else {
        // Create file item
        const a = document.createElement('a');
        a.href = '#';
        a.className = 'file-link';
        this.setLinkContent(a, 'markdown', item.name);
        a.onclick = (e) => {
          e.preventDefault();
          this.loadFile(item.name, paneId);
        };
        li.appendChild(a);
      }

      parentUl.appendChild(li);
    }
  },

  // Load file content with security validation
  async loadFile(fileId, paneId = 'primary') {
    // 1. Path Traversal Defense: Validate against allowlist
    if (!this.isValidPath(fileId)) {
      console.error('Blocked attempt to load unauthorized file:', fileId);
      if (paneId === 'primary') {
        this.showNotFound(fileId);
      }
      return false;
    }

    const contentDiv = document.getElementById(
      paneId === 'primary' ? 'content-primary' : 'content-secondary'
    );
    const headerDiv = contentDiv.querySelector('.content-header');
    const bodyDiv = contentDiv.querySelector('.content-body');

    // Update state
    if (paneId === 'primary') {
      this.state.currentFile = fileId;
    } else {
      this.state.compareFile = fileId;
    }

    // Update header
    const filePathSlot = headerDiv.querySelector('.file-path-slot');
    if (filePathSlot) {
      filePathSlot.textContent = fileId;
    }

    // Update URL hash
    const newHash = this.getHashString();
    if (window.location.hash.slice(1) !== newHash) {
      window.location.hash = newHash;
    }

    // Highlight active file
    this.highlightActiveFile(fileId, paneId);

    // Cache check
    if (this.contentCache.has(fileId)) {
      bodyDiv.innerHTML = this.contentCache.get(fileId);
      this.attachContentListeners(bodyDiv, paneId);
      this.attachHeadingAnchors(bodyDiv);
      return true;
    }

    bodyDiv.innerHTML = '<div class="loading">Loading...</div>';

    try {
      const response = await fetch(`${this.basePath}${fileId}`);
      if (!response.ok) throw new Error('Failed to load file');
      const md = await response.text();

      // Ensure marked is ready
      if (typeof marked === 'undefined') throw new Error('Marked not loaded');

      const rawHtml = marked.parse(md);

      // 3. Security: Sanitize all rendered HTML
      if (typeof DOMPurify === 'undefined') throw new Error('DOMPurify not loaded');
      const cleanHtml = DOMPurify.sanitize(rawHtml, {
        USE_PROFILES: { html: true },
        ALLOWED_TAGS: [
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'p',
          'a',
          'ul',
          'ol',
          'li',
          'code',
          'pre',
          'blockquote',
          'table',
          'thead',
          'tbody',
          'tr',
          'th',
          'td',
          'hr',
          'img',
          'span',
          'div',
          'strong',
          'em',
          'del',
        ],
        ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'id'],
      });

      const finalHtml = `<div class="markdown-body">${cleanHtml}</div>`;
      bodyDiv.innerHTML = finalHtml;
      this.contentCache.set(fileId, finalHtml);

      this.attachContentListeners(bodyDiv, paneId);
      this.attachHeadingAnchors(bodyDiv);
      return true;
    } catch (error) {
      console.error(error);
      // SECURITY: Use textContent for fileId to prevent XSS
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error';
      errorDiv.textContent = `Error loading ${fileId}.`;
      bodyDiv.innerHTML = '';
      bodyDiv.appendChild(errorDiv);
      return false;
    }
  },

  /**
   * Resolve a relative path from a base path.
   * Handles ./, ../, and bare filenames.
   * @param {string} basePath - The current file path (e.g., "configuration/config-schema.md")
   * @param {string} relativePath - The link href (e.g., "../architecture/overview.md")
   * @returns {string} Resolved path (e.g., "architecture/overview.md")
   */
  resolvePath(basePath, relativePath) {
    // Get directory of current file
    const parts = basePath.split('/');
    parts.pop(); // Remove filename, keep directory parts

    // Handle the relative path
    const relParts = relativePath.split('/');
    for (const part of relParts) {
      if (part === '.' || part === '') {
        // Current directory, skip
        continue;
      } else if (part === '..') {
        // Parent directory
        parts.pop();
      } else {
        // Normal path segment
        parts.push(part);
      }
    }

    return parts.join('/');
  },

  // Attach listeners for link/image rewriting
  attachContentListeners(container, paneId) {
    // Get current file path for resolving relative links
    const currentFile = paneId === 'primary' ? this.state.currentFile : this.state.compareFile;

    // 4. Link Rewriting: Intercept internal .md links (case-insensitive)
    // FR-014: Strip #anchor suffix before path resolution
    container.querySelectorAll('a').forEach((link) => {
      const href = link.getAttribute('href');
      if (!href || href.startsWith('http')) return;

      // FR-002: Anchor-only hashes should scroll within the current document
      if (href.startsWith('#')) {
        const anchorId = href.slice(1);
        if (anchorId) {
          link.onclick = (e) => {
            e.preventDefault();
            this.scrollToAnchor(anchorId);
          };
        }
        return;
      }

      // Check if this is an internal markdown link (with or without anchor)
      // Patterns: ./x.md, ../x.md, x.md, path/x.md, x.md#anchor
      const mdMatch = href.match(/^([^#]*\.md)(#.*)?$/i);
      if (!mdMatch) return;

      const mdPath = mdMatch[1]; // The .md path without anchor
      const anchor = mdMatch[2] || ''; // The #anchor part (if any)

      // Resolve the relative path from the current document
      const resolvedPath = currentFile
        ? this.resolvePath(currentFile, mdPath)
        : mdPath.split('/').pop();

      // Case-insensitive lookup: find the matching file in allowlist
      const matchedFile = this.getAllowedPaths().find(
        (allowed) => allowed.toLowerCase() === resolvedPath.toLowerCase()
      );
      if (matchedFile) {
        link.onclick = (e) => {
          e.preventDefault();
          this.loadFile(matchedFile, paneId).then(() => {
            // If there's an anchor, scroll to that element after load
            if (anchor) {
              const targetId = anchor.substring(1); // Remove leading #
              const targetElement = document.getElementById(targetId);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth' });
              }
            }
          });
        };
      }
    });

    // 5. Image Rewriting: Resolve relative images from parent docs dir
    container.querySelectorAll('img').forEach((img) => {
      const src = img.getAttribute('src');
      if (src && !src.startsWith('http') && !src.startsWith('data:') && !src.startsWith('/')) {
        img.src = `${this.basePath}${src}`;
      }
    });

    // 6. Mermaid Diagrams: Render code blocks with language-mermaid
    if (typeof mermaid !== 'undefined') {
      container.querySelectorAll('pre code.language-mermaid').forEach((codeBlock) => {
        const pre = codeBlock.parentElement;
        const diagramSource = codeBlock.textContent;

        // Create a container for the rendered diagram
        const diagramDiv = document.createElement('div');
        diagramDiv.className = 'mermaid';
        diagramDiv.textContent = diagramSource;

        // Replace the pre/code with the mermaid div
        pre.parentElement.replaceChild(diagramDiv, pre);
      });

      // Re-run mermaid to render the new diagrams
      mermaid.run();
    }
  },

  // FR-002a: Attach click handlers to heading anchors for scroll-to-id without URL hash change
  attachHeadingAnchors(container) {
    // Find all headings with IDs (generated by marked with headerIds: true)
    container
      .querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]')
      .forEach((heading) => {
        const headingId = heading.id;
        if (!headingId) return;

        // Check if anchor link already exists
        if (heading.querySelector('.heading-anchor')) return;

        // Create anchor link element
        const anchor = document.createElement('a');
        anchor.className = 'heading-anchor';
        anchor.href = `#${headingId}`;
        anchor.textContent = '#';
        anchor.title = 'Link to this section';

        // Prevent default and scroll without changing URL hash
        anchor.onclick = (e) => {
          e.preventDefault();
          heading.scrollIntoView({ behavior: 'smooth' });
          // Optionally copy link to clipboard for sharing
          // navigator.clipboard.writeText(window.location.href.split('#')[0] + '#' + headingId);
        };

        // Append anchor to heading
        heading.appendChild(anchor);
      });
  },

  // Highlight active file in tree
  highlightActiveFile(fileId, paneId) {
    const treeId = paneId === 'primary' ? 'tree-primary' : 'tree-secondary';
    const tree = document.getElementById(treeId);
    if (!tree) return;

    tree.querySelectorAll('.file-link').forEach((link) => {
      link.classList.remove('active');
      if (link.textContent.trim() === fileId) {
        link.classList.add('active');
      }
    });
  },

  // Toggle compare mode
  toggleCompareMode() {
    this.state.compareMode = !this.state.compareMode;
    const viewer = document.getElementById('viewer');
    const btn = document.getElementById('compare-btn');

    if (this.state.compareMode) {
      viewer.classList.add('compare-mode');
      btn.classList.add('active');
      this.setLinkContent(btn, 'close', 'Exit Compare');

      const secondaryTree = document.getElementById('tree-secondary');
      if (secondaryTree && secondaryTree.children.length === 0) {
        this.buildTree(this.fileTree, secondaryTree, 'secondary');
      }
    } else {
      viewer.classList.remove('compare-mode');
      btn.classList.remove('active');
      this.setLinkContent(btn, 'compare', 'Compare');
      this.state.compareFile = null;
    }

    const newHash = this.getHashString();
    if (window.location.hash.slice(1) !== newHash) {
      window.location.hash = newHash;
    }
  },

  // Get current hash string
  getHashString() {
    let hash = '';
    if (this.state.currentFile) {
      hash = this.state.currentFile;
      if (this.state.compareMode && this.state.compareFile) {
        hash += '|' + this.state.compareFile;
      }
    }
    return hash;
  },

  // Decode hash values without throwing on malformed encoding
  safeDecodeHash(value) {
    try {
      return decodeURIComponent(value);
    } catch {
      return value;
    }
  },

  // Scroll to a heading anchor within the current document
  scrollToAnchor(anchorId) {
    if (!anchorId) return;
    const targetId = anchorId.startsWith('#') ? anchorId.slice(1) : anchorId;
    const targetElement = document.getElementById(targetId);
    if (targetElement) {
      targetElement.scrollIntoView({ behavior: 'smooth' });
    }
  },

  // Parse URL hash
  parseHash() {
    const rawHash = window.location.hash.slice(1);
    if (!rawHash) return null;

    const hash = this.safeDecodeHash(rawHash);
    const parts = hash.split('|');
    const primary = parts[0] || null;
    const secondary = parts[1] || null;
    const primaryIsDoc = primary ? /\.md$/i.test(primary) : false;
    const secondaryIsDoc = secondary ? /\.md$/i.test(secondary) : false;

    if (!primaryIsDoc && !secondaryIsDoc) {
      return { primary: null, secondary: null, anchor: hash };
    }

    return {
      primary: primaryIsDoc ? primary : null,
      secondary: secondaryIsDoc ? secondary : null,
      anchor: null,
    };
  },

  // Load manifest file
  async loadManifest() {
    try {
      const response = await fetch('./manifest.json');
      if (!response.ok) {
        console.error('Failed to load manifest.json');
        return false;
      }
      const manifest = await response.json();
      // Use tree structure for v2+ manifests, fall back to flat files
      this.manifestTree = manifest.tree || null;
      this.fileTree = manifest.files || [];
      console.log(
        `Loaded ${this.fileTree.length} documentation files from manifest (v${manifest.version || 1})`
      );
      return true;
    } catch (error) {
      console.error('Error loading manifest:', error);
      return false;
    }
  },

  // Initialize application
  async init() {
    // 1. Parse hash synchronously BEFORE any rendering (single-pass architecture)
    const hashState = this.parseHash();
    const targetDoc = hashState?.primary || 'index.md';

    // 2. Load manifest (async)
    await this.loadManifest();

    // Basic marked setup
    if (typeof marked !== 'undefined') {
      marked.setOptions({
        headerIds: true, // Enable header IDs for heading anchors
        mangle: false,
      });
    }

    // Initialize Mermaid with dark theme
    if (typeof mermaid !== 'undefined') {
      mermaid.initialize({
        startOnLoad: false,
        theme: 'dark',
        securityLevel: 'strict',
      });
    }

    const primaryTree = document.getElementById('tree-primary');
    // Use tree structure if available, otherwise fall back to flat files
    const treeData = this.manifestTree || this.fileTree;
    this.buildTree(treeData, primaryTree, 'primary');

    const compareBtn = document.getElementById('compare-btn');
    compareBtn.onclick = () => this.toggleCompareMode();

    this.setupMobileMenu();
    this.setupPaneNavButtons();

    // 3. Single render pass - load target doc or show not found
    if (this.isValidPath(targetDoc)) {
      const loaded = await this.loadFile(targetDoc, 'primary');
      if (loaded && hashState?.secondary) {
        this.toggleCompareMode();
        await this.loadFile(hashState.secondary, 'secondary');
      }
    } else if (targetDoc === 'index.md') {
      // FR-013: Graceful fallback when index.md doesn't exist
      this.showWelcome();
    } else {
      this.showNotFound(targetDoc);
    }

    if (hashState?.anchor) {
      this.scrollToAnchor(hashState.anchor);
    }

    // Handle hash changes
    window.onhashchange = async () => {
      const state = this.parseHash();
      if (!state) return;

      if (state.anchor) {
        this.scrollToAnchor(state.anchor);
        return;
      }

      const target = state.primary || 'index.md';
      if (target !== this.state.currentFile) {
        if (this.isValidPath(target)) {
          await this.loadFile(target, 'primary');
        } else {
          this.showNotFound(target);
        }
      }
    };
  },

  // Setup mobile menu
  setupMobileMenu() {
    const menuBtn = document.getElementById('menu-btn');
    const primarySidebar = document.getElementById('sidebar-primary');
    const overlay = document.getElementById('sidebar-overlay');

    if (!menuBtn || !primarySidebar || !overlay) return;

    menuBtn.onclick = () => {
      const primarySidebar = document.getElementById('sidebar-primary');
      const secondarySidebar = document.getElementById('sidebar-secondary');
      const overlay = document.getElementById('sidebar-overlay');

      if (this.state.compareMode && secondarySidebar) {
        if (primarySidebar.classList.contains('open')) {
          primarySidebar.classList.remove('open');
          secondarySidebar.classList.add('open');
        } else if (secondarySidebar.classList.contains('open')) {
          secondarySidebar.classList.remove('open');
          overlay.classList.remove('visible');
        } else {
          primarySidebar.classList.add('open');
          overlay.classList.add('visible');
        }
      } else {
        primarySidebar.classList.toggle('open');
        overlay.classList.toggle('visible');
      }
    };

    overlay.onclick = () => {
      primarySidebar.classList.remove('open');
      const secondarySidebar = document.getElementById('sidebar-secondary');
      if (secondarySidebar) secondarySidebar.classList.remove('open');
      overlay.classList.remove('visible');
    };
  },

  // Mobile navigation buttons
  setupPaneNavButtons() {
    const primaryNavBtn = document.getElementById('nav-btn-primary');
    const secondaryNavBtn = document.getElementById('nav-btn-secondary');

    if (primaryNavBtn) {
      primaryNavBtn.onclick = () => {
        document.getElementById('sidebar-primary').classList.add('open');
        document.getElementById('sidebar-overlay').classList.add('visible');
      };
    }

    if (secondaryNavBtn) {
      secondaryNavBtn.onclick = () => {
        const secondarySidebar = document.getElementById('sidebar-secondary');
        if (secondarySidebar) {
          secondarySidebar.classList.add('open');
          document.getElementById('sidebar-overlay').classList.add('visible');
        }
      };
    }
  },
};

document.addEventListener('DOMContentLoaded', () => DocsViewer.init());
